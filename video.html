<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Portraitifier — Convert 16:9 ➜ 9:16 without Cropping</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121822;
      --panel-2: #0e141d;
      --text: #e7edf6;
      --muted: #9bb0c3;
      --accent: #5cc8ff;
      --accent-2: #7affb7;
      --danger: #ff6b6b;
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: radial-gradient(1200px 600px at 10% -10%, #122033, #091018), var(--bg);
      color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100dvh; display: grid; grid-template-rows: auto 1fr auto;
    }
    header {
      padding: 18px 22px; display: flex; align-items: center; gap: 14px; background: linear-gradient(180deg, rgba(255,255,255,0.04), transparent), var(--panel);
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    header h1 { font-size: 1.1rem; margin: 0; letter-spacing: 0.2px; }
    header .pill { font-size: .75rem; color: var(--bg); background: linear-gradient(135deg, var(--accent), var(--accent-2)); padding: 4px 8px; border-radius: 999px; font-weight: 700; }

    main { display: grid; grid-template-columns: 380px 1fr; gap: 16px; padding: 16px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }

    .panel { background: linear-gradient(180deg, rgba(255,255,255,0.04), transparent), var(--panel-2); border: 1px solid rgba(255,255,255,0.06); border-radius: var(--radius); }

    .controls { padding: 16px; display: grid; gap: 14px; align-content: start; }
    .group { display: grid; gap: 10px; background: rgba(255,255,255,0.02); padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.06); }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    label { font-size: .9rem; color: var(--muted); }
    input[type="range"] { width: 100%; }
    input[type="file"] { width: 100%; padding: 10px; border: 1px dashed rgba(255,255,255,0.2); border-radius: 12px; background: rgba(255,255,255,0.03); }
    select, input[type="number"], input[type="text"], button {
      background: rgba(255,255,255,0.06); color: var(--text); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 10px 12px; font-size: .95rem;
    }
    button.primary { background: linear-gradient(135deg, var(--accent), var(--accent-2)); color: #00253a; border: none; font-weight: 800; }
    button.ghost { background: rgba(255,255,255,0.06); }
    button.danger { background: var(--danger); color: white; border: none; font-weight: 800; }
    button:disabled { opacity: .55; cursor: not-allowed; }

    .preview-wrap { display: grid; grid-template-rows: auto 1fr auto; padding: 12px; gap: 8px; }

    .stage {
      aspect-ratio: 9/16; width: min(52vw, 420px); justify-self: center; background: #000; position: relative; border-radius: 24px; overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.5), 0 0 0 1px rgba(255,255,255,.06) inset;
    }
    .canvas, video { width: 100%; height: 100%; display: block; }

    .tips { font-size: .85rem; color: var(--muted); }
    .kbd { background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.2); border-bottom-width: 3px; border-radius: 6px; padding: 0 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    footer { padding: 12px 16px; font-size: .85rem; color: var(--muted); display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    a { color: var(--accent-2); text-decoration: none; }

    .meter { height: 16px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.12); border-radius: 999px; overflow: hidden; }
    .meter > i { display: block; height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); transition: width .2s linear; }

    .inline { display: inline-flex; align-items: center; gap: 8px; }
  </style>
</head>
<body>
  <header>
    <div class="pill">No‑Crop 16:9 ➜ 9:16</div>
    <h1>Portraitifier – Fill the whole 9:16 screen without losing any content</h1>
  </header>

  <main>
    <!-- Controls -->
    <section class="panel controls">
      <div class="group">
        <label for="file">1) Upload your 16:9 video</label>
        <input id="file" type="file" accept="video/*" />
        <div class="tips">Works fully in‑browser. Nothing uploads anywhere.</div>
      </div>

      <div class="group">
        <div class="row">
          <label>2) Output resolution</label>
          <select id="resolution">
            <option value="720x1280">720×1280 (HD Portrait)</option>
            <option value="1080x1920" selected>1080×1920 (FHD Portrait)</option>
            <option value="1440x2560">1440×2560 (QHD Portrait)</option>
          </select>
        </div>
        <div class="row">
          <label>Target FPS</label>
          <input id="fps" type="number" min="15" max="60" step="1" value="30" />
          <span class="tips">Use the source FPS if unsure.</span>
        </div>
      </div>

      <div class="group">
        <label>3) Background fill (covers entire 9:16)</label>
        <div class="row">
          <label class="inline"><input type="radio" name="bgmode" value="blur" checked> Blurred clone</label>
          <label class="inline"><input type="radio" name="bgmode" value="solid"> Solid color</label>
          <label class="inline"><input type="radio" name="bgmode" value="none"> Black</label>
        </div>
        <div id="bgBlurControls" class="row">
          <label style="min-width: 90px;">Blur</label>
          <input id="blur" type="range" min="0" max="60" value="30" />
        </div>
        <div id="bgColorControls" class="row" style="display:none;">
          <label style="min-width: 90px;">Color</label>
          <input id="bgcolor" type="color" value="#000000" />
        </div>
        <div class="row">
          <label style="min-width: 90px;">Darken</label>
          <input id="darken" type="range" min="0" max="80" value="20" />
          <span class="tips">Helps the foreground pop.</span>
        </div>
      </div>

      <div class="group">
        <label>4) Foreground framing (never crops)</label>
        <div class="row">
          <label style="min-width: 90px;">Vertical offset</label>
          <input id="yoffset" type="range" min="-100" max="100" value="0" />
        </div>
        <div class="row">
          <label style="min-width: 90px;">Padding</label>
          <input id="padding" type="range" min="0" max="200" value="0" />
          <span class="tips">Optional extra gap around the full video.</span>
        </div>
      </div>

      <div class="group">
        <label>5) Export</label>
        <div class="row" style="gap: 8px;">
          <button id="start" class="primary" disabled>Start Recording</button>
          <button id="stop" class="danger" disabled>Stop</button>
          <button id="download" class="ghost" disabled>Download</button>
        </div>
        <div class="row">
          <div class="meter" style="flex:1"><i id="meterBar"></i></div>
          <span id="meterText" class="tips" style="width: 120px; text-align:right;">00:00</span>
        </div>
        <div class="tips">Output is <b>WEBM (VP9 + original audio)</b> for widest browser support. You can transcode to MP4 in most editors if needed.</div>
      </div>
    </section>

    <!-- Preview / Canvas -->
    <section class="panel preview-wrap">
      <div class="row" style="padding: 10px 12px; justify-content: space-between;">
        <div class="tips">Live preview (what you see is what gets exported)</div>
        <div id="dimBadge" class="pill" style="font-weight: 700;">1080×1920 @ 30 fps</div>
      </div>
      <div class="stage">
        <canvas id="canvas" class="canvas"></canvas>
      </div>
      <div class="tips" style="padding: 0 12px 12px;">
        Shortcuts: <span class="kbd">Space</span> play/pause, <span class="kbd">J/K/L</span> seek, <span class="kbd">,</span>/<span class="kbd">.</span> frame.
      </div>
    </section>
  </main>

  <footer>
    <div>Built for creators who need <b>no‑crop 16:9 ➜ 9:16</b> with blurred backfill for YouTube Shorts, Reels & TikTok — all on‑device.</div>
    <div><a href="#" id="how">How it works</a></div>
  </footer>

  <!-- Hidden media elements (sources for drawing & audio) -->
  <video id="video" playsinline preload="metadata" style="display:none"></video>

  <script>
    const els = {
      file: document.getElementById('file'),
      canvas: document.getElementById('canvas'),
      video: document.getElementById('video'),
      start: document.getElementById('start'),
      stop: document.getElementById('stop'),
      download: document.getElementById('download'),
      meterBar: document.getElementById('meterBar'),
      meterText: document.getElementById('meterText'),
      resolution: document.getElementById('resolution'),
      fps: document.getElementById('fps'),
      blur: document.getElementById('blur'),
      bgmode: document.querySelectorAll('input[name="bgmode"]'),
      darken: document.getElementById('darken'),
      bgcolor: document.getElementById('bgcolor'),
      bgBlurControls: document.getElementById('bgBlurControls'),
      bgColorControls: document.getElementById('bgColorControls'),
      yoffset: document.getElementById('yoffset'),
      padding: document.getElementById('padding'),
      dimBadge: document.getElementById('dimBadge'),
    };

    // Global state
    let ctx, running = false, rafId = null, rVFC = 'requestVideoFrameCallback' in HTMLVideoElement.prototype;
    let rec = null, recordedChunks = [], recStartTs = 0, drawFps = 30;
    let audioCtx, sourceNode, destNode;

    // Setup canvas
    function setCanvasSizeFromSelect() {
      const [w, h] = els.resolution.value.split('x').map(Number);
      els.canvas.width = w; els.canvas.height = h;
      els.dimBadge.textContent = `${w}×${h} @ ${els.fps.value} fps`;
      if (!ctx) ctx = els.canvas.getContext('2d');
    }
    setCanvasSizeFromSelect();

    els.resolution.addEventListener('change', setCanvasSizeFromSelect);
    els.fps.addEventListener('change', () => { drawFps = clamp(+els.fps.value, 15, 60); });

    // BG mode toggles
    els.bgmode.forEach(r => r.addEventListener('change', () => {
      const mode = getBgMode();
      els.bgBlurControls.style.display = mode === 'blur' ? '' : 'none';
      els.bgColorControls.style.display = mode === 'solid' ? '' : 'none';
    }));

    // Utilities
    const clamp = (n, a, b) => Math.min(Math.max(n, a), b);
    function formatTime(s) {
      const m = Math.floor(s/60).toString().padStart(2,'0');
      const ss = Math.floor(s%60).toString().padStart(2,'0');
      return `${m}:${ss}`;
    }
    const getBgMode = () => [...els.bgmode].find(r => r.checked)?.value || 'blur';

    // File loading
    els.file.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      els.video.src = url;
      els.video.load();
      try { await els.video.play(); els.video.pause(); } catch {}

      els.start.disabled = false; // enable export
      running = true; loop();
    });

    // Keyboard shortcuts for preview control
    document.addEventListener('keydown', (e) => {
      if (!els.video.src) return;
      if (e.code === 'Space') { e.preventDefault(); if (els.video.paused) els.video.play(); else els.video.pause(); }
      if (e.key === 'l' || e.key === 'L') els.video.currentTime = Math.min(els.video.duration, els.video.currentTime + 5);
      if (e.key === 'j' || e.key === 'J') els.video.currentTime = Math.max(0, els.video.currentTime - 5);
      if (e.key === ',') els.video.pause(), els.video.currentTime = Math.max(0, els.video.currentTime - (1/(+els.fps.value||30)));
      if (e.key === '.') els.video.pause(), els.video.currentTime = Math.min(els.video.duration, els.video.currentTime + (1/(+els.fps.value||30)));
    });

    // Drawing logic: background (cover) + foreground (contain)
    function drawFrame() {
      const v = els.video; if (!v.videoWidth || !v.videoHeight) return;
      const W = els.canvas.width, H = els.canvas.height;
      const vw = v.videoWidth, vh = v.videoHeight;

      // Clear
      ctx.clearRect(0,0,W,H);

      // Chosen padding & offset
      const pad = +els.padding.value;
      const yOff = (+els.yoffset.value / 100) * (H/4);

      // Background
      const mode = getBgMode();
      if (mode === 'blur') {
        const scaleCover = Math.max(W / vw, H / vh);
        const bw = vw * scaleCover, bh = vh * scaleCover;
        const bx = (W - bw) / 2, by = (H - bh) / 2;
        const blurPx = +els.blur.value;
        const darkenPct = +els.darken.value;
        ctx.save();
        ctx.filter = `blur(${blurPx}px) brightness(${1 - darkenPct/100})`;
        ctx.drawImage(v, bx, by, bw, bh);
        ctx.restore();
      } else if (mode === 'solid') {
        ctx.fillStyle = els.bgcolor.value;
        ctx.fillRect(0,0,W,H);
      } else {
        // Black default
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,W,H);
      }

      // Foreground (full content, no crop) – "contain"
      const scaleContain = Math.min((W - pad*2) / vw, (H - pad*2) / vh);
      const fw = vw * scaleContain, fh = vh * scaleContain;
      const fx = (W - fw) / 2; let fy = (H - fh) / 2 + yOff;
      // Clamp to canvas so user can't offset past edges
      fy = clamp(fy, -((H - fh)/2), ((H - fh)/2));

      // Draw the clean foreground frame on top
      ctx.drawImage(v, fx, fy, fw, fh);
    }

    // Animation / preview loop
    function loop() {
      if (!running) return;
      if (rVFC) {
        els.video.requestVideoFrameCallback(() => { drawFrame(); loop(); });
      } else {
        drawFrame();
        rafId = setTimeout(loop, 1000/(+els.fps.value||30));
      }
    }

    // Recording setup using MediaRecorder on canvas stream + original audio
    async function setupAudioGraph() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaElementSource(els.video);
      destNode = audioCtx.createMediaStreamDestination();
      sourceNode.connect(destNode);
      // Also route to speakers for monitoring
      sourceNode.connect(audioCtx.destination);
    }

    function getMixedStream() {
      const fps = clamp(+els.fps.value||30, 15, 60);
      const canvasStream = els.canvas.captureStream(fps);
      const tracks = [...canvasStream.getVideoTracks()];
      if (destNode) {
        const audioTracks = destNode.stream.getAudioTracks();
        if (audioTracks.length) tracks.push(audioTracks[0]);
      }
      return new MediaStream(tracks);
    }

    function pickMime() {
      const candidates = [
        'video/webm;codecs=vp9,opus',
        'video/webm;codecs=vp8,opus',
        'video/webm',
      ];
      for (const c of candidates) { if (MediaRecorder.isTypeSupported(c)) return c; }
      return '';
    }

    els.start.addEventListener('click', async () => {
      if (!els.video.src) return;
      await setupAudioGraph();
      if (audioCtx.state === 'suspended') await audioCtx.resume();

      // Ensure playback for live drawing during recording
      try { await els.video.play(); } catch {}

      const stream = getMixedStream();
      const mimeType = pickMime();
      recordedChunks = [];
      rec = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 8_000_000 });

      rec.ondataavailable = (e) => { if (e.data && e.data.size > 0) recordedChunks.push(e.data); };
      rec.onstop = () => {
        const blob = new Blob(recordedChunks, { type: rec.mimeType || 'video/webm' });
        const url = URL.createObjectURL(blob);
        els.download.href = url;
        const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
        els.download.download = `portraitifier-${stamp}.webm`;
        els.download.disabled = false;
      };

      rec.start(1000); // timeslice for ondataavailable
      recStartTs = performance.now();
      els.start.disabled = true; els.stop.disabled = false; els.download.disabled = true;
      tickMeter();
    });

    els.stop.addEventListener('click', () => {
      if (rec && rec.state !== 'inactive') {
        rec.stop();
        els.stop.disabled = true; els.start.disabled = false;
      }
    });

    function tickMeter() {
      if (!rec || rec.state === 'inactive') return;
      const elapsed = (performance.now() - recStartTs) / 1000;
      els.meterText.textContent = formatTime(elapsed);
      const pct = (els.video.currentTime / (els.video.duration || 1)) * 100;
      els.meterBar.style.width = pct + '%';
      requestAnimationFrame(tickMeter);
    }

    // Live update on any control change
    [els.blur, els.darken, els.bgcolor, els.yoffset, els.padding].forEach(el => el.addEventListener('input', drawFrame));

    // Update preview size text when FPS/res changes
    els.fps.addEventListener('input', () => els.dimBadge.textContent = `${els.canvas.width}×${els.canvas.height} @ ${els.fps.value} fps`);

    // Help modal (simple alert)
    document.getElementById('how').addEventListener('click', (e) => {
      e.preventDefault();
      alert(`How it works:\n\n• The app lays your full 16:9 video on top using 'contain' — so nothing is cropped.\n• It fills the 9:16 background either with a blurred clone, a solid color, or black.\n• Export captures the canvas + original audio via MediaRecorder entirely in your browser.\n\nTips:\n• Use 1080×1920 @ 30 fps for Shorts.\n• Increase blur + darken for better subject focus.\n• Use the Vertical offset to nudge action into the center for captions UI.`);
    });

    // Initial blank render
    drawFrame();
  </script>
</body>
</html>
